\section[\empty]{Objective 3: Long Short-Term Memory (LSTM) Architecture}

\begin{frame}{Transformer and Attention Mechanism}
	\begin{columns}[c] % [c] = vertically center
		
		% Left column
		\begin{column}{0.48\textwidth}
			\centering
			\scalebox{0.5}{\input{figures/transformer.tex}}
		\end{column}
		
		% Right column
		\begin{column}{0.48\textwidth}
			\centering
			\scalebox{0.7}{\input{figures/multihead_attention.tex}}
		\end{column}
		
	\end{columns}
\end{frame}

%\begin{frame}{Objective 3: Long Short-Term Memory (LSTM) Architecture}
%\begin{columns}[t]
%\begin{column}{0.65\textwidth}
%
%
%\begin{tikzpicture}[
%	% GLOBAL CFG
%	font=\sf \scriptsize,
%	>=LaTeX,
%	% Styles
%	cell/.style={% For the main box
%		rectangle, 
%		rounded corners=5mm, 
%		draw,
%		very thick,
%	},
%	operator/.style={%For operators like +  and  x
%		circle,
%		draw,
%		inner sep=-0.5pt,
%		minimum height =.2cm,
%	},
%	function/.style={%For functions
%		ellipse,
%		draw,
%		inner sep=1pt
%	},
%	ct/.style={% For external inputs and outputs
%		circle,
%		draw,
%		line width = .75pt,
%		minimum width=1cm,
%		inner sep=1pt,
%	},
%	gt/.style={% For internal inputs
%		rectangle,
%		draw,
%		minimum width=4mm,
%		minimum height=3mm,
%		inner sep=1pt
%	},
%	mylabel/.style={% something new that I have learned
%		font=\scriptsize\sffamily
%	},
%	ArrowC1/.style={% Arrows with rounded corners
%		rounded corners=.25cm,
%		thick,
%	},
%	ArrowC2/.style={% Arrows with big rounded corners
%		rounded corners=.5cm,
%		thick,
%	},
%	]
%	
%	%Start drawing the thing...    
%	% Draw the cell: 
%	\node [cell, minimum height =4cm, minimum width=6cm] at (0,0){} ;
%	
%	% Draw inputs named ibox#
%	\node [gt] (ibox1) at (-2,-0.75) {$\sigma$};
%	\node [gt] (ibox2) at (-1.5,-0.75) {$\sigma$};
%	\node [gt, minimum width=1cm] (ibox3) at (-0.5,-0.75) {Tanh};
%	\node [gt] (ibox4) at (0.5,-0.75) {$\sigma$};
%	
%	% Draw opérators   named mux# , add# and func#
%	\node [operator] (mux1) at (-2,1.5) {$\times$};
%	\node [operator] (add1) at (-0.5,1.5) {+};
%	\node [operator] (mux2) at (-0.5,0) {$\times$};
%	\node [operator] (mux3) at (1.5,0) {$\times$};
%	\node [function] (func1) at (1.5,0.75) {Tanh};
%	
%	% Draw External inputs? named as basis c,h,x
%	\node[ct, label={[mylabel]Cell}] (c) at (-4,1.5) {$\boldsymbol{c}_{t-1}$};
%	\node[ct, label={[mylabel]Hidden}] (h) at (-4,-1.5) {$\boldsymbol{h}_{t-1}$};
%	\node[ct, label={[mylabel]left:Input}] (x) at (-2.5,-3) {{$\boldsymbol{x}_{t}^{(i)}$}};
%	
%	% Draw External outputs? named as basis c2,h2,x2
%	\node[ct, label={[mylabel]\empty}] (c2) at (4,1.5) {$\boldsymbol{c}_{t}$};
%	\node[ct, label={[mylabel]\empty}] (h2) at (4,-1.5) {$\boldsymbol{h}_{t}$};
%%	\node[ct, label={[mylabel]left:\empty}] (x2) at (2.5,3) {$\boldsymbol{h}_{t}$};
%	
%	% Start connecting all.
%	%Intersections and displacements are used. 
%	% Drawing arrows    
%	\draw [ArrowC1] (c) -- (mux1) -- (add1) -- (c2);
%	
%	% Inputs
%	\draw [ArrowC2] (h) -| (ibox4);
%	\draw [ArrowC1] (h -| ibox1)++(-0.5,0) -| (ibox1); 
%	\draw [ArrowC1] (h -| ibox2)++(-0.5,0) -| (ibox2);
%	\draw [ArrowC1] (h -| ibox3)++(-0.5,0) -| (ibox3);
%	\draw [ArrowC1] (x) -- (x |- h)-| (ibox3);
%	
%	% Internal
%	\draw [->, ArrowC2] (ibox1) -- (mux1);
%	\draw [->, ArrowC2] (ibox2) |- (mux2);
%	\draw [->, ArrowC2] (ibox3) -- (mux2);
%	\draw [->, ArrowC2] (ibox4) |- (mux3);
%	\draw [->, ArrowC2] (mux2) -- (add1);
%	\draw [->, ArrowC1] (add1 -| func1)++(-0.5,0) -| (func1);
%	\draw [->, ArrowC2] (func1) -- (mux3);
%	
%	%Outputs
%	\draw [-, ArrowC2] (mux3) |- (h2);
%%	\draw (c2 -| x2) ++(0,-0.1) coordinate (i1);
%%	\draw [-, ArrowC2] (h2 -| x2)++(-0.5,0) -| (i1);
%%	\draw [-, ArrowC2] (i1)++(0,0.2) -- (x2);
%	
%\end{tikzpicture}
%\end{column}
%
%    % equations column, also top‐aligned
%\begin{column}[t]{0.45\textwidth}
%
%	\small
%	\begin{align*}
%\boldsymbol{i}_t &= \sigma\bigl(\boldsymbol{W}_{ii}\,\boldsymbol{x}_t^{(i)} 
%+ \boldsymbol{W}_{hi}\,\boldsymbol{h}_{t-1}
%+ \boldsymbol{b}_i\bigr),\\
%\boldsymbol{f}_t &= \sigma\bigl(\boldsymbol{W}_{if}\,\boldsymbol{x}_t^{(i)} 
%+ \boldsymbol{W}_{hf}\,\boldsymbol{h}_{t-1}
%+ \boldsymbol{b}_f\bigr),\\
%\boldsymbol{g}_t &= \tanh\bigl(\boldsymbol{W}_{ig}\,\boldsymbol{x}_t^{(i)} 
%+ \boldsymbol{W}_{hg}\,\boldsymbol{h}_{t-1}
%+ \boldsymbol{b}_g\bigr),\\
%\boldsymbol{o}_t &= \sigma\bigl(\boldsymbol{W}_{io}\,\boldsymbol{x}_t^{(i)} 
%+ \boldsymbol{W}_{ho}\,\boldsymbol{h}_{t-1}
%+ \boldsymbol{b}_o\bigr),\\
%\boldsymbol{C}_t &= \boldsymbol{f}_t \odot \boldsymbol{C}_{t-1}
%+ \boldsymbol{i}_t \odot \boldsymbol{g}_t,\\
%\boldsymbol{h}_t &= \boldsymbol{o}_t \odot \tanh\bigl(\boldsymbol{C}_t\bigr).
%	\end{align*}
%	
%\(\odot\) is the Hadamard product, and \(\sigma\) the sigmoid function.
%
%	
%\end{column}
%\end{columns}
%
%
%\end{frame}
%	
%\begin{frame}[t]{Missing‐Value Imputation}
%	\begin{columns}[t]
%		\begin{column}{0.55\textwidth}
%			\begin{block}{}
%				At each time step \(t\), missing channel entries in \(\boldsymbol{x}_t^{(i)}\) can be imputed sequentially from the hidden state via an affine map:
%				\[
%				\hat{x}_{t,j}^{(i)}
%				= \boldsymbol{w}_j^{\mathsf T}\,\boldsymbol{h}_t + b_j,
%				\quad j = 1,\dots,p.
%				\]
%			\end{block}
%
%		\end{column}
%		\begin{column}{0.45\textwidth}
%			\[
%			\begin{aligned}
%				\{\boldsymbol{W}_{ii},\,\boldsymbol{W}_{if},\,\boldsymbol{W}_{ig},\,\boldsymbol{W}_{io}\}
%				&\in \mathbb{R}^{H \times p},\\
%				\{\boldsymbol{W}_{hi},\,\boldsymbol{W}_{hf},\,\boldsymbol{W}_{hg},\,\boldsymbol{W}_{ho}\}
%				&\in \mathbb{R}^{H \times H},\\
%				\{\boldsymbol{b}_{i},\,\boldsymbol{b}_{f},\,\boldsymbol{b}_{g},\,\boldsymbol{b}_{o}\}
%				&\in \mathbb{R}^{H},\\
%				\boldsymbol{w}_j &\in \mathbb{R}^{H},\\
%				b_j &\in \mathbb{R},\\
%				\boldsymbol{h}_t,\,\boldsymbol{C}_t &\in \mathbb{R}^{H}.
%			\end{aligned}
%			\]
%			Here \(H\) denotes the dimensionality of the hidden state.
%		\end{column}
%	\end{columns}
%\end{frame}
%
%\begin{frame}[fragile]{Architecture}
%	\resizebox{\textwidth}{!}{
%		\tikzset{trapezium stretches=true}
%		\centering
%		\begin{tikzpicture}[font=\sffamily, >=stealth, node distance=8mm]
%			% Latent variable (z)
%			\node[rectangle, fill=MyAccent, text=white, font=\sffamily\large, minimum height=3cm, text width=3cm, align=center] (z) {Latent\\ Representation ($\boldsymbol{h}$)};
%			
%			% Encoder trapezoid
%			\node[trapezium, fill=MyAccent!20, minimum width=4cm, minimum height=4cm,
%			trapezium left angle=86, trapezium right angle=86, shape border rotate=270,
%			anchor=east, left=5mm of z, font=\sffamily\large, text=MyDarkBlue] (enc) {Encoder (LSTM)};
%			
%			
%			% Gaussian Process circle
%			\node[circle, fill=MyAccent!20, text=MyDarkBlue, font=\sffamily\small,
%			below=2cm of z, minimum size=2cm, align=center] (gp) {Gaussian\\Process};
%			
%			% Arrows and labels
%			\draw[<-, MyDarkBlue, thick] (enc.west) -- ++(-1.5,0) node[left, align=right, text=MyDarkBlue] {Input};
%			\draw[->, MyAccent, thick] (z.south) -- (gp.north);
%			\draw[->, MyDarkBlue, thick] (gp.east) -- ++(1.5,0) node[right, align=left, text=MyDarkBlue] {Predictive Distribution\\(Inference)};
%		\end{tikzpicture}
%	}
%\end{frame}